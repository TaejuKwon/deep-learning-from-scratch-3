# **복잡한 계산 그래프**


**15.1 역전파의 올바른 계산 순서**

그래프의 연결된 형태를 '위상(topology)'라고 한다. -> 다양한 위상의 계산 그래프에 대응할 수 있어야 함.

계산 중간에 출력이 2 개인 함수 a가 있다면, 역전파시 a에 2개의 미분값이 모두 전파된 후에야 a에서 x로 미분값을 전파할 수 있음. (D, B, C, A) 혹은 (D, C, B, A)의 순서로 역전파가 진행됨.

**함수 B, C의 역전파를 모두 끝내고 나서 함수 A를 역전파 함**

 
```python
# funcs = [D]
f = funcs.pop()     # D
...

for x in f.inputs:
    funcs.append(x.creator)
# funcs = [B, C]
```

가장 먼저 funcs에 D가 들어간 상태로 시작. D가 꺼내지고, D의 입력변수의 창조자인 B와 C가 funcs에 추가됨.

```python
# funcs = [B, C]
f = funcs.pop()     # C
# funcs = [B]
...

for x in f.inputs:
    funcs.append(x.creator)
# funcs = [B, A]
```

그 후 C가 pop된 후, funcs에는 B만 남는다. 그 후, C의 입력 변수의 창조자인 A가 funcs에 추가됨.
이어서 다시 마지막 원소인 A가 꺼내짐, 여기서 문제 발생. 원래는 B를 꺼내야 하는데 (x.grad를 계산하기 위해선 B와 C의 역전파를 먼저 끝내야함) A를 꺼냄.

**15.2 함수 우선순위**

funcs 리스트에는 다음에 처리할 함수의 '후보'들이 들어있다. 지금의 Dezero에서는 '마지막' 원소만 꺼내 왔었음. 우리는 함수들을 처리할 '우선순위'가 필요함.

우리는 어떤 함수가 어떤 변수를 만들어내는지에 대한 창조자-피조물 관계를 알고 있음. (x and x.creator) 이 관계를 기준으로 우리는 함수와 변수의 세대(우선순위)를 파악할 수 있음.